#pragma once

/*
GLSLSource.h

The file contains the glsl source code for SurfExtract as string. 

Rafael Radkowski
Iowa State University
rafael@iastate.edu
Dec 2019
--------------------------------------------------------------
Last edits:
*/


#include <iostream>
#include <string>


namespace surfe {

static const std::string  glsl_position_renderer_vs =
"#version 410 core						\n"                                       
"										\n"	
"uniform mat4 projectionMatrix;         \n"                           
"uniform mat4 viewMatrix;               \n"                            
"uniform mat4 modelMatrix;				\n"
"										\n"
"//uniform vec3 light_position;			\n"
"uniform vec3 light_direction;			\n"
"										\n"
"in vec3 in_Position;                   \n"                                                                                        
"in vec3 in_Normal;						\n"
"										\n"
"out vec3 pass_Normal;					\n"
"out vec3 pass_Position;				\n"
"out vec4 pass_Color;					\n"		                         
"										\n"
"void main(void)						\n"                                                 
"{										\n"
"	// just in model coordinates		\n"
"	pass_Position = vec3(   modelMatrix  *  vec4(in_Position, 1.0));    \n" 
"																		\n"
"	// make it red														\n"
"	pass_Color = vec4(1.0,0.0,0.0,1.0);									\n"	
"																		\n"
"   pass_Normal =   vec3( transpose(inverse(viewMatrix * modelMatrix)) *  vec4(in_Normal, 0.0));    \n"                    
"																									\n"
"	// pass the position																			\n"
"	gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(in_Position, 1.0);				\n"
"																									\n"
"	gl_PointSize = 4.0;																				\n"
"}																									\n"
"\n";

static const std::string   glsl_position_renderer_fs =
"#version 410 core										\n"
"#define MAX_LIGHTS 4									\n"
"														\n"
"uniform mat4 projectionMatrix;							\n"                            
"uniform mat4 viewMatrix;                               \n"          
"uniform mat4 modelMatrix;								\n"
"														\n"
"in vec3 pass_Normal;									\n"
"in vec3 pass_Position;									\n"
"in vec4 pass_Color;									\n"
"														\n"
"// The material parameters								\n"
"uniform struct LightSource {							\n"
"    vec3 position;										\n"
"	vec3 direction;										\n"
"	vec3 color;											\n"
"	float intensity;									\n"
"	float cutoff_in; // inner							\n"
"	float cutoff_out; // outer							\n"
"	float k1;    //attenuation							\n"
"	float k2;    //attenuation							\n"
"	bool used;											\n"
"	int  type;  //0:point, 1:spot, 2:directional		\n"
"} light[MAX_LIGHTS];									\n"
"														\n"
"														\n"
"// The material parameters								\n"
"uniform struct Material {								\n"
"    vec3  diffColor;									\n"
"	float diffInt;										\n"
" 	vec3  ambColor;										\n"
" 	float ambInt;										\n"
" 	vec3  specColor;									\n"
" 	float specInt;										\n"
" 	float shininess;									\n"
"} mat[1];												\n"
"														\n"
"out vec4 color;										\n"
"														\n"
"void main(void)										\n"         
"{														\n"
"	color = vec4(pass_Position, 0.0);					\n"
"}														\n"
"\n";	




static const std::string glsl_display_renderer_vs = 
"#version 410 core                                                  \n"
"																	\n"
"uniform mat4 projectionMatrix;										\n"
"uniform mat4 viewMatrix;                                           \n"
"uniform mat4 modelMatrix;											\n"
"																	\n"
"uniform float display_scale;										\n"
"																	\n"
"in vec3 in_Position;                                               \n"                                                            
"in vec3 in_Normal;													\n"
"in vec2 in_Texture;												\n"
"																	\n"
"out vec3 pass_Color;												\n"
"out vec3 pass_Normal;												\n"
"out vec2 pass_Texture;                                             \n"  
"																	\n"
"void main(void)													\n" 
"{																	\n"
"	gl_Position = vec4(in_Position, 1.0) * vec4(1.3, 1.3, 1.0, 1.0) -  vec4( display_scale * 0.3, display_scale * 0.3, 0.0, 0.0);	\n"
"    pass_Normal = in_Normal.xyz;// vec3( transpose(inverse(modelMatrix))  * vec4(in_Normal, 0.0) );								\n"
"	pass_Color = vec3(0.6, 0.6, 0.6);																								\n"
"	pass_Texture = in_Texture;																										\n"
"}																																	\n"                    
"\n";


static const std::string glsl_display_renderer_fs = 
"#version 410 core									\n"                      
"													\n"
"in vec3 pass_Color;								\n"
"in vec2 pass_Texture;								\n"
"in vec3 pass_Normal;								\n"
"													\n"
"uniform sampler2D tex;								\n"
"													\n"
"out vec4 color;									\n"
"													\n"
"void main(void)									\n"           
"{													\n"
"	vec4 tex_color =  texture(tex, pass_Texture.xy);\n"
"													\n"
"	color = vec4(tex_color.x, tex_color.y, tex_color.z, 1.0);// + vec4(pass_Color, 1.0f) * 0.2;      \n"
"	// Set the fragment depth to a small value to make sure that the object is always in front.		 \n"	
"	gl_FragDepth = 0.000001;																		 \n"
"}																							     	 \n"
"\n";



static const std::string glsl_lit_scene_vs = 
"#version 410 core											\n"	                        
"                                                           \n"     
"uniform mat4 projectionMatrix;                             \n"       
"uniform mat4 viewMatrix;                                   \n"        
"uniform mat4 modelMatrix;									\n"
"															\n"
"//uniform vec3 light_position;								\n"
"uniform vec3 light_direction;								\n"
"															\n"
"in vec3 in_Position;										\n"                                                                                   
"in vec3 in_Normal;											\n"
"															\n"
"out vec3 pass_Normal;										\n"
"out vec3 pass_Position;									\n"
"out vec4 pass_Color;										\n"     
"                                                           \n"     
"void main(void)                                            \n"      
"{															\n"
"	// for lighting											\n"
"	pass_Position = vec3(  viewMatrix *  modelMatrix  *  vec4(in_Position, 1.0));						\n"
"																										\n"
"	// make it red																						\n"
"	pass_Color = vec4(1.0,0.0,0.0,1.0);																	\n"
"																										\n"
"   pass_Normal =   vec3( transpose(inverse(viewMatrix * modelMatrix)) *  vec4(in_Normal, 0.0));		\n"                
"																										\n"
"	// pass the position																				\n"
"	gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(in_Position, 1.0);					\n"
"																										\n"
"	gl_PointSize = 120;																					\n"
"}																										\n"
"\n";


static const std::string glsl_lit_scene_fs = 
"#version 410 core									\n" 
"#define MAX_LIGHTS 4								\n"
"													\n"
"uniform mat4 projectionMatrix;						\n"              
"uniform mat4 viewMatrix;							\n"             
"uniform mat4 modelMatrix;							\n"
"                                                   \n"             
"in vec3 pass_Normal;								\n"
"in vec3 pass_Position;								\n"
"in vec4 pass_Color;								\n"
"													\n"
"// The material parameters							\n"
"uniform struct LightSource {						\n"
"    vec3 position;									\n"
"	vec3 direction;									\n"
"	vec3 color;										\n"
"	float intensity;								\n"
"	float cutoff_in; // inner						\n"
"	float cutoff_out; // outer						\n"
"	float k1;    //attenuation						\n"
"	float k2;    //attenuation						\n"
"	bool used;										\n"
"	int  type;  //0:point, 1:spot, 2:directional	\n"
"} light[MAX_LIGHTS];								\n"
"													\n"
"													\n"
"// The material parameters							\n"
"uniform struct Material {							\n"
"    vec3  diffColor;								\n"
" 	float diffInt;									\n"
" 	vec3  ambColor;									\n"
" 	float ambInt;									\n"
" 	vec3  specColor;								\n"
" 	float specInt;									\n"
" 	float shininess;								\n"
"} mat[1];											\n"
"													\n"
"													\n"
"out vec4 color;									\n"
"													\n"
"/*													\n"
"Per-fragment light.								\n"
"Note that all vectors need to be in camera/eye-space. \n"
"@param L - vector between light and fragment position.\n"
"@param E - eye point									\n"
"@param s - the light source							\n"
"@param m - the material								\n"
"*/														\n"
"vec4 useLight(vec3 L, vec3 E, vec3 N, LightSource s, Material m)									\n"
"{																									\n"
"	vec4 color = vec4(0.0,0.0,0.0,0.0);																\n"
"																									\n"
"	// diffuse light																				\n"
"	vec3 Idiff =  m.diffInt * m.diffColor *  max(dot(L, N), 0.0);									\n"
"	Idiff = clamp(Idiff, 0.0, 1.0);																	\n"
"																									\n"
"	// ambient light																				\n"
"	vec4 Iamb = vec4( m.ambColor, 1.0) * m.ambInt;													\n"
"																									\n"
"	// specular light																				\n"
"	vec3 R = reflect(L, N);																			\n"
"	vec3 Ispec =  m.specInt * m.specColor *  pow(max(dot(R, E), 0.0), m.shininess);					\n"
"																									\n"
"	// calculate color																				\n"
"	color = max(vec4( ( Idiff + Ispec) * s.color, 1.0), Iamb)  * s.intensity;						\n"
"																									\n"
"	// attenuation																					\n"
"	float dist = length(L);																			\n"
"	float Iatt = 1 / (1 + s.k1 * dist + s.k2*s.k2 * dist);											\n"
"																									\n"
"	if(s.type == 0)//pointlight																		\n"
"	{																								\n"
"		color = color * Iatt;																		\n"
"	}																								\n"
"	else if(s.type == 1)// spotlight																\n"
"	{																								\n"
"		vec4 K = viewMatrix * vec4(normalize(s.direction - s.position), 0.0);						\n"
"		float a = dot(-L,K.xyz); // angle between light dir and fragment position.					\n"
"																									\n"
"		float c = smoothstep(1.0-s.cutoff_out, 1.0-s.cutoff_in, a);									\n"
"		Iatt = Iatt * c; // multiple with attenuation to maintain the distance effect.				\n"
"																									\n"
"		color = color * Iatt; // attenutation														\n"
"	}																								\n"
"																									\n"
"																									\n"
"	return color;																					\n"
"}																									\n"
"\n"
"\n"                       
"void main(void)																					\n"                          
"{																									\n"
"	// eye position																					\n"
"	vec3 E = normalize( vec3(viewMatrix[3][0], viewMatrix[3][1], viewMatrix[3][2]) );				\n"
"																									\n"
"																									\n"
"	// calc light.																					\n"
"	vec4 mixed = vec4(0.0,0.0,0.0,1.0);																\n"
"	for (int i=0; i<MAX_LIGHTS; i++){																\n"
"																									\n"
"		if(light[i].used == false) continue;														\n"
"																									\n"
"		// light position if camera frame															\n"
"		vec4 L_c = viewMatrix * vec4(light[i].position, 1.0);										\n"
"																									\n"
"		// light to fragment																		\n"
"		vec3 L = normalize( L_c.xyz - pass_Position );												\n"
"		if(light[i].type == 2) L = light[i].direction;// direct light								\n"
"																									\n"
"		// checks whether the light was set.														\n"
"		// Multiple lights blend adative															\n"
"		mixed += useLight( L,  E,  pass_Normal, light[i], mat[0]);									\n"
"																									\n"
"	}																								\n"
"																									\n"
"	color = mixed;																					\n"
"}																									\n"
"\n";

}// namespace surfe 
